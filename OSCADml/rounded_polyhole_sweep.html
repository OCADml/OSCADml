<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>rounded_polyhole_sweep (OSCADml.rounded_polyhole_sweep)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">OSCADml</a> &#x00BB; rounded_polyhole_sweep</nav><header class="odoc-preamble"><h1 id="rounded-sweeps"><a href="#rounded-sweeps" class="anchor"></a>Rounded sweeps</h1><pre class="language-ocaml"><code>open OCADml
open OSCADml</code></pre><p>Create a bezier spline function which passes through all of points in <code>control</code> using <span class="xref-unresolved"><code>Bezier3.of_path</code></span>, and interpolate <code>20</code> points along it to create our <code>path</code> with <span class="xref-unresolved"><code>Bezier3.curve</code></span>.</p><pre class="language-ocaml"><code>let control =
  V3.[ v 5. 5. 12.; v 0. 20. 20.; v 30. 30. 0.; v 50. 20. 5.; v 35. (-10.) 15. ]

let path = Bezier3.curve ~fn:30 @@ Bezier3.of_path control</code></pre><p>We can quickly visualize <code>path</code>, and the <code>control</code> points that it passes through by using the <a href="OSCADml/Debug/index.html#val-show_path3"><code>Debug.show_path3</code></a> helper, which places a <a href="OSCADml/Scad/index.html#type-d3"><code>Scad.d3</code></a> shape at each point along the path (this takes a function from index to shape, rather than a shape directly to allow for differentiating the points, <i>e.g.</i> numbering with <a href="OSCADml/Scad/index.html#val-text"><code>Scad.text</code></a>).</p><pre class="language-ocaml"><code>let () =
  Scad.to_file &quot;bezier_spline_path.scad&quot;
  @@ Scad.union
       [ Debug.show_path3 (fun _ -&gt; Scad.sphere 1.) path
       ; Debug.show_path3
           (fun _ -&gt; Scad.(color ~alpha:0.3 Color.Magenta @@ sphere 2.))
           control
       ]</code></pre>
<p style="text-align:center;">
<img src="../assets/bezier_spline_path.png" style="width:150mm;"/>
</p> <p>Draw a 2d polygon with a chamfered square outline, and two circular holes. Chamfering the square outer path is accomplished via <span class="xref-unresolved"><code>Path2.roundover</code></span>, which takes a <span class="xref-unresolved"><code>Path2.Round.t</code></span> specifation, built here using the <span class="xref-unresolved"><code>Path2.Round.flat</code></span> constructor, that tells <span class="xref-unresolved"><code>Path2.roundover</code></span> to apply <code>~corner</code> to all of the points of the given path.</p><pre class="language-ocaml"><code>let poly =
  let holes =
    let s = Path2.circle ~fn:90 2.
    and d = 1.9 in
    Path2.[ translate (v2 (-.d) (-.d)) s; translate (v2 d d) s ]
  and outer =
    Path2.square ~center:true (v2 10. 10.)
    |&gt; Path2.Round.(flat ~corner:(chamf (`Width 2.)))
    |&gt; Path2.roundover
  in
  Poly2.make ~holes outer</code></pre><p>2d shapes defined with <span class="xref-unresolved"><code>Poly2.t</code></span> can be translated into OpenSCAD polygons by way of <span class="xref-unresolved"><code>Poly2.to_scad</code></span>.</p><pre class="language-ocaml"><code>let () = Scad.to_file &quot;chamfered_square_with_holes.scad&quot; (Scad.of_poly2 poly)</code></pre>
<p style="text-align:center;">
<img src="../assets/chamfered_square_with_holes.png" style="width:150mm;"/>
</p> <p><span class="xref-unresolved"><code>Mesh.sweep</code></span> derived functions take a <code>~caps</code> parameter that specifies what to do with the end faces of the extruded mesh. By default, both caps are flat and identical to the input polygon (<span class="xref-unresolved"><code>Mesh.Cap.flat_caps</code></span>), but in this example, we will be rounding them over.</p><p>To build our <code>caps</code>, we'll use the <span class="xref-unresolved"><code>Mesh.Cap.capped</code></span> constructor which takes specification types for how we would like to treat the bottom and top faces of our extrusion. In this case, we'll be applying roundovers to both the <code>bot</code>tom and <code>top</code> faces, so we use <span class="xref-unresolved"><code>Mesh.Cap.round</code></span> which takes an <span class="xref-unresolved"><code>Mesh.Cap.offsets</code></span> containing the offset distance/radius and &quot;vertical&quot; step for each outline of the outer roundover, and optionally, the desired treatment of the inner paths (as <code>~holes</code>). Typically, the offsets will be generated by a helper such as <span class="xref-unresolved"><code>Mesh.Cap.chamf</code></span> and <span class="xref-unresolved"><code>Mesh.Cap.circ</code></span> below.</p><p>Here we apply a negative (outward flaring) chamfer to the bottom face, setting <code>holes</code> to <code>`Same</code>, so that the circular holes in <code>poly</code> are also expanded, rather than pinched off (default is (<code>~holes:`Flip</code>), which negates the outer roundover for inner paths). For the top face, we specify a positive (inward) circular roundover, leaving <code>holes</code> as its default since we want the holes to flare out instead.</p><pre class="language-ocaml"><code>let caps =
  Mesh.Cap.(
    capped
      ~bot:(round ~holes:`Same @@ chamf ~height:(-1.2) ~angle:(Float.pi /. 8.) ())
      ~top:(round @@ circ (`Radius 0.5)))</code></pre><p>Extrude <code>poly</code> along <code>path</code>, with rounding over the end caps according to <code>caps</code> using <span class="xref-unresolved"><code>Mesh.path_extrude</code></span>.</p><pre class="language-ocaml"><code>let mesh = Mesh.path_extrude ~path ~caps poly</code></pre><p>Convert our mesh into an OpenSCAD polyhedron and output to file with <a href="OSCADml/Scad/index.html#val-of_mesh"><code>Scad.of_mesh</code></a>.</p><pre class="language-ocaml"><code>let () = Scad.to_file &quot;rounded_polyhole_sweep.scad&quot; (Scad.of_mesh mesh)</code></pre>
<p style="text-align:center;">
<img src="../assets/rounded_polyhole_sweep.png" style="width:150mm;"/>
</p> <p>Rounded 3d paths for sweeping can also be drawn with the help of the <span class="xref-unresolved"><code>Path3.Round</code></span> module, which works much the same as its counterpart in <span class="xref-unresolved"><code>Path2</code></span> that we used to chamfer our <code>poly</code> earlier.</p><pre class="language-ocaml"><code>let rounded_path =
  Path3.(
    roundover ~fn:32
    @@ Round.flat
         ~closed:true
         ~corner:(Round.circ (`Radius 10.))
         (v3 (-25.) 25. 0. :: Path3.square (v2 50. 50.)))</code></pre><p><span class="xref-unresolved"><code>Mesh.path_extrude</code></span> (and other functions derived from <code>Mesh.sweep</code>) can be given <code>~caps:`Looped</code>, which will connect the final position of the sweep up with the beginning, rather than sealing both ends off with caps. If the swept polygon has holes (as our <code>poly</code> does), they will be included, and continuous much like the outer shape.</p><pre class="language-ocaml"><code>let () =
  let loop = Scad.of_mesh @@ Mesh.(path_extrude ~caps:Cap.looped ~path:rounded_path poly)
  and cut =
    Scad.cylinder ~fn:50 ~center:true ~height:11. 5.
    |&gt; Scad.scale (v3 1.2 1. 1.)
    |&gt; Scad.translate (v3 20. (-4.) 0.)
  in
  Scad.difference loop [ cut ] |&gt; Scad.to_file &quot;chamfered_loop.scad&quot;</code></pre>
<p style="text-align:center;">
<img src="../assets/chamfered_loop.png" style="width:150mm;"/>
</p> </header><div class="odoc-content"></div></body></html>